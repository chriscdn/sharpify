{"version":3,"file":"sharpify.modern.js","sources":["../src/is-number.ts","../src/is-image.ts","../src/_sharpify.ts","../src/sharpify.ts"],"sourcesContent":["/**\n * Based on https://www.npmjs.com/package/is-number, but modified as a\n * type-guard.\n *\n * @param num\n * @returns\n */\nexport const isNumber = (num: unknown): num is number => {\n    if (typeof num === \"number\") {\n        return num - num === 0;\n    } else if (typeof num === \"string\" && num.trim() !== \"\") {\n        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n    } else {\n        return false;\n    }\n};\n","export const isImage = async (filePath: string): Promise<boolean> => {\n  try {\n    //\n    // Seems necessary for the CJS export to work.\n    //\n    const { default: imageType } = await import(\"image-type\");\n    const { minimumBytes } = await import(\"image-type\");\n    const { readChunk } = await import(\"read-chunk\");\n\n    const buffer = await readChunk(filePath, { length: minimumBytes });\n    const type = await imageType(buffer);\n    return [\"image/jpeg\", \"image/png\"].includes(type?.mime ?? \"\");\n  } catch (e) {\n    return false;\n  }\n};\n","import sharp from \"sharp\";\nimport { isNumber } from \"./is-number\";\nimport { isImage } from \"./is-image\";\nimport { FitEnum } from \"sharp\";\nimport { Memoize } from \"@chriscdn/memoize\";\n\nexport type SharpifyParameters = {\n  blur: number; // https://sharp.pixelplumbing.com/api-operation#blur\n  brightness: number;\n  fit: keyof FitEnum;\n  height: number;\n  normalise: boolean; // https://sharp.pixelplumbing.com/api-operation#normalise\n  rotate: number;\n  saturation: number;\n  width: number;\n  withMetadata: boolean;\n  withoutEnlargement: boolean;\n};\n\n// we only ever render the same image once.. no need to cache\nsharp.cache(false);\n\nexport const sharpifyIt = async (\n  source: string,\n  target: string,\n  args: SharpifyParameters,\n) => {\n  const blur = assertIntegerValue(args.blur, 0, 100);\n  const brightness = assertIntegerValue(args.brightness, 0, 2);\n  const fit = args.fit;\n  const height = assertIntegerValue(args.height, 0, args.height);\n  const normalise = args.normalise;\n  const rotate = assertIntegerValue(args.rotate, -20, 20);\n  const saturation = assertIntegerValue(args.saturation, 0, 1);\n  const width = assertIntegerValue(args.width, 0, args.width);\n  const withMetadata = args.withMetadata;\n  const withoutEnlargement = args.withoutEnlargement;\n\n  let s = await sharp(source);\n\n  if (withMetadata) {\n    s = s.withMetadata();\n  }\n\n  const metadata = await s.metadata();\n\n  const originalWidth = metadata.width;\n  const originalHeight = metadata.height;\n\n  if (normalise) {\n    // normalise seems to have minimal effect\n    s = s.normalise();\n  }\n\n  if (isNumber(blur) && blur > 0) {\n    s = s.blur(blur);\n  }\n\n  if (isNumber(saturation) && saturation < 1) {\n    s = s.modulate({ saturation });\n  }\n\n  if (isNumber(brightness) && brightness != 1) {\n    s = s.modulate({ brightness });\n  }\n\n  if (rotate !== 0) {\n    // this doesnt take the orientation into account :(\n    // https://sharp.pixelplumbing.com/api-operation#rotate\n    s = s.rotate(rotate);\n\n    const box = boxify(originalWidth, originalHeight, rotate);\n\n    s = s.extract({\n      left: box.left,\n      top: box.top,\n      width: box.width,\n      height: box.height,\n    });\n  } else {\n    // this normalises rotation - see sharp docs\n    s = s.rotate();\n  }\n\n  if (width || height) {\n    s = s.resize({\n      width,\n      height,\n      fit,\n      withoutEnlargement,\n    });\n  }\n\n  await s.toFile(target);\n\n  if (await isImage(target)) {\n    // all good! exit gracefully\n    return target;\n  } else {\n    throw new Error(\"Invalid target generated.\");\n  }\n};\n\nconst assertIntegerValue = (\n  value: unknown,\n  min: number,\n  max: number,\n): number | null => {\n  if (isNumber(value)) {\n    return Math.min(max, Math.max(min, value));\n  } else {\n    return null;\n  }\n};\n\nconst radians = (degrees: number): number => {\n  return (degrees * Math.PI) / 180;\n};\n\nconst boxify = Memoize((width: number, height: number, degrees: number) => {\n  const rads = radians(Math.abs(degrees));\n\n  const sine = Math.sin(rads);\n  const cosine = Math.cos(rads);\n\n  let left = height * sine;\n  let top = width * sine;\n\n  const bigWidth = height * sine + width * cosine;\n  const bigHeight = height * cosine + width * sine;\n\n  let newWidth = bigWidth - 2 * left;\n  let newHeight = bigHeight - 2 * top;\n\n  const originalAspectRatio = width / height;\n  const newAspectRatio = newWidth / newHeight;\n\n  if (originalAspectRatio < newAspectRatio) {\n    const newWidthConstrained = originalAspectRatio * newHeight;\n\n    left = left + (newWidth - newWidthConstrained) / 2;\n    newWidth = newWidthConstrained;\n  } else {\n    // taller\n    const newHeightConstrained = newWidth / originalAspectRatio;\n\n    top = top + (newHeight - newHeightConstrained) / 2;\n    newHeight = newHeightConstrained;\n  }\n\n  return {\n    left: Math.round(left),\n    top: Math.round(top),\n    width: Math.round(newWidth),\n    height: Math.round(newHeight),\n    aspectRatio: newWidth / newHeight,\n  };\n});\n","import { Semaphore } from \"@chriscdn/promise-semaphore\";\nimport { sharpifyIt, type SharpifyParameters } from \"./_sharpify\";\n\nconst semaphore = new Semaphore();\n\nconst defaultArgs: SharpifyParameters = {\n  blur: 0,\n  brightness: 1,\n  fit: \"inside\",\n  height: null,\n  normalise: false,\n  rotate: 0,\n  saturation: 1,\n  width: null,\n  withMetadata: false,\n  withoutEnlargement: true,\n};\n\nexport const sharpify = async (\n  source: string,\n  target: string,\n  params: Partial<SharpifyParameters>,\n) => {\n  const args = {\n    ...defaultArgs,\n    ...params,\n  };\n\n  try {\n    await semaphore.acquire(target);\n\n    return await sharpifyIt(source, target, args);\n  } finally {\n    semaphore.release(target);\n  }\n};\n"],"names":["isNumber","num","trim","Number","isFinite","isImage","async","_type$mime","default","imageType","import","minimumBytes","readChunk","buffer","filePath","length","type","includes","mime","e","sharp","cache","assertIntegerValue","value","min","max","Math","boxify","Memoize","width","height","degrees","rads","PI","radians","abs","sine","sin","cosine","cos","left","top","newWidth","newHeight","originalAspectRatio","newWidthConstrained","newHeightConstrained","round","aspectRatio","semaphore","Semaphore","defaultArgs","blur","brightness","fit","normalise","rotate","saturation","withMetadata","withoutEnlargement","sharpify","source","target","params","args","_extends","acquire","s","metadata","originalWidth","originalHeight","modulate","box","extract","resize","toFile","Error","sharpifyIt","release"],"mappings":"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"}