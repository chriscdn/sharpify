{"version":3,"file":"sharpify.module.js","sources":["../src/is-number.ts","../src/is-image.ts","../src/_sharpify.ts","../src/sharpify.ts"],"sourcesContent":["/**\n * Based on https://www.npmjs.com/package/is-number, but modified as a\n * type-guard.\n *\n * @param num\n * @returns\n */\nexport const isNumber = (num: unknown): num is number => {\n    if (typeof num === \"number\") {\n        return num - num === 0;\n    } else if (typeof num === \"string\" && num.trim() !== \"\") {\n        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n    } else {\n        return false;\n    }\n};\n","export const isImage = async (filePath: string): Promise<boolean> => {\n  try {\n    //\n    // Seems necessary for the CJS export to work.\n    //\n    const { default: imageType } = await import(\"image-type\");\n    const { minimumBytes } = await import(\"image-type\");\n    const { readChunk } = await import(\"read-chunk\");\n\n    const buffer = await readChunk(filePath, { length: minimumBytes });\n    const type = await imageType(buffer);\n    return [\"image/jpeg\", \"image/png\"].includes(type?.mime ?? \"\");\n  } catch (e) {\n    return false;\n  }\n};\n","import sharp from \"sharp\";\nimport { isNumber } from \"./is-number\";\nimport { isImage } from \"./is-image\";\nimport { FitEnum } from \"sharp\";\nimport { Memoize } from \"@chriscdn/memoize\";\n\nexport type SharpifyParameters = {\n  blur: number; // https://sharp.pixelplumbing.com/api-operation#blur\n  brightness: number;\n  fit: keyof FitEnum;\n  height: number;\n  normalise: boolean; // https://sharp.pixelplumbing.com/api-operation#normalise\n  rotate: number;\n  saturation: number;\n  width: number;\n  withMetadata: boolean;\n  withoutEnlargement: boolean;\n};\n\n// we only ever render the same image once.. no need to cache\nsharp.cache(false);\n\nexport const sharpifyIt = async (\n  source: string,\n  target: string,\n  args: SharpifyParameters,\n) => {\n  const blur = assertIntegerValue(args.blur, 0, 100);\n  const brightness = assertIntegerValue(args.brightness, 0, 2);\n  const fit = args.fit;\n  const height = assertIntegerValue(args.height, 0, args.height);\n  const normalise = args.normalise;\n  const rotate = assertIntegerValue(args.rotate, -20, 20);\n  const saturation = assertIntegerValue(args.saturation, 0, 1);\n  const width = assertIntegerValue(args.width, 0, args.width);\n  const withMetadata = args.withMetadata;\n  const withoutEnlargement = args.withoutEnlargement;\n\n  let s = await sharp(source);\n\n  if (withMetadata) {\n    s = s.withMetadata();\n  }\n\n  const metadata = await s.metadata();\n\n  const originalWidth = metadata.width;\n  const originalHeight = metadata.height;\n\n  if (normalise) {\n    // normalise seems to have minimal effect\n    s = s.normalise();\n  }\n\n  if (isNumber(blur) && blur > 0) {\n    s = s.blur(blur);\n  }\n\n  if (isNumber(saturation) && saturation < 1) {\n    s = s.modulate({ saturation });\n  }\n\n  if (isNumber(brightness) && brightness != 1) {\n    s = s.modulate({ brightness });\n  }\n\n  if (rotate !== 0) {\n    // this doesnt take the orientation into account :(\n    // https://sharp.pixelplumbing.com/api-operation#rotate\n    s = s.rotate(rotate);\n\n    const box = boxify(originalWidth, originalHeight, rotate);\n\n    s = s.extract({\n      left: box.left,\n      top: box.top,\n      width: box.width,\n      height: box.height,\n    });\n  } else {\n    // this normalises rotation - see sharp docs\n    s = s.rotate();\n  }\n\n  if (width || height) {\n    s = s.resize({\n      width,\n      height,\n      fit,\n      withoutEnlargement,\n    });\n  }\n\n  await s.toFile(target);\n\n  if (await isImage(target)) {\n    // all good! exit gracefully\n    return target;\n  } else {\n    throw new Error(\"Invalid target generated.\");\n  }\n};\n\nconst assertIntegerValue = (\n  value: unknown,\n  min: number,\n  max: number,\n): number | null => {\n  if (isNumber(value)) {\n    return Math.min(max, Math.max(min, value));\n  } else {\n    return null;\n  }\n};\n\nconst radians = (degrees: number): number => {\n  return (degrees * Math.PI) / 180;\n};\n\nconst boxify = Memoize((width: number, height: number, degrees: number) => {\n  const rads = radians(Math.abs(degrees));\n\n  const sine = Math.sin(rads);\n  const cosine = Math.cos(rads);\n\n  let left = height * sine;\n  let top = width * sine;\n\n  const bigWidth = height * sine + width * cosine;\n  const bigHeight = height * cosine + width * sine;\n\n  let newWidth = bigWidth - 2 * left;\n  let newHeight = bigHeight - 2 * top;\n\n  const originalAspectRatio = width / height;\n  const newAspectRatio = newWidth / newHeight;\n\n  if (originalAspectRatio < newAspectRatio) {\n    const newWidthConstrained = originalAspectRatio * newHeight;\n\n    left = left + (newWidth - newWidthConstrained) / 2;\n    newWidth = newWidthConstrained;\n  } else {\n    // taller\n    const newHeightConstrained = newWidth / originalAspectRatio;\n\n    top = top + (newHeight - newHeightConstrained) / 2;\n    newHeight = newHeightConstrained;\n  }\n\n  return {\n    left: Math.round(left),\n    top: Math.round(top),\n    width: Math.round(newWidth),\n    height: Math.round(newHeight),\n    aspectRatio: newWidth / newHeight,\n  };\n});\n","import Semaphore from \"@chriscdn/promise-semaphore\";\nimport { sharpifyIt, type SharpifyParameters } from \"./_sharpify\";\n\nconst semaphore = new Semaphore();\n\nconst defaultArgs: SharpifyParameters = {\n  blur: 0,\n  brightness: 1,\n  fit: \"inside\",\n  height: null,\n  normalise: false,\n  rotate: 0,\n  saturation: 1,\n  width: null,\n  withMetadata: false,\n  withoutEnlargement: true,\n};\n\nexport const sharpify = async (\n  source: string,\n  target: string,\n  params: Partial<SharpifyParameters>,\n) => {\n  const args = {\n    ...defaultArgs,\n    ...params,\n  };\n\n  try {\n    await semaphore.acquire(target);\n\n    return await sharpifyIt(source, target, args);\n  } finally {\n    semaphore.release(target);\n  }\n};\n"],"names":["isNumber","num","trim","Number","isFinite","isImage","filePath","Promise","resolve","import","then","_ref","imageType","_ref2","minimumBytes","_ref3","readChunk","length","buffer","type","_type$mime","includes","mime","_catch","sharp","cache","assertIntegerValue","value","min","max","Math","boxify","Memoize","width","height","degrees","rads","PI","radians","abs","sine","sin","cosine","cos","left","top","newWidth","newHeight","originalAspectRatio","newWidthConstrained","newHeightConstrained","round","aspectRatio","semaphore","Semaphore","defaultArgs","blur","brightness","fit","normalise","rotate","saturation","withMetadata","withoutEnlargement","sharpify","source","target","params","args","_extends","acquire","s","metadata","originalWidth","originalHeight","modulate","box","extract","resize","toFile","_isImage","Error","e","reject","sharpifyIt","_finallyRethrows","_wasThrown","_result","release"],"mappings":"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"}