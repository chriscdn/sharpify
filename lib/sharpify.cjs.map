{"version":3,"file":"sharpify.cjs","sources":["../src/is-number.ts","../src/is-image.ts","../src/_sharpify.ts","../src/sharpify.ts"],"sourcesContent":["/**\n * Based on https://www.npmjs.com/package/is-number, but modified as a\n * type-guard.\n *\n * @param num\n * @returns\n */\nexport const isNumber = (num: unknown): num is number => {\n    if (typeof num === \"number\") {\n        return num - num === 0;\n    } else if (typeof num === \"string\" && num.trim() !== \"\") {\n        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n    } else {\n        return false;\n    }\n};\n","import sharp from \"sharp\";\n\n// export const isImage = async (filePath: string): Promise<boolean> => {\n//   try {\n//     //\n//     // Seems necessary for the CJS export to work.\n//     //\n//     const { default: imageType } = await import(\"image-type\");\n//     const { minimumBytes } = await import(\"image-type\");\n//     const { readChunk } = await import(\"read-chunk\");\n\n//     const buffer = await readChunk(filePath, { length: minimumBytes });\n//     const type = await imageType(buffer);\n//     return [\"image/jpeg\", \"image/png\"].includes(type?.mime ?? \"\");\n//   } catch (e) {\n//     return false;\n//   }\n// };\n\nconst isImage = async (filePath: string) => {\n  try {\n    await sharp(filePath).resize(1, 1).toBuffer(); // Tries to decode the image\n    return true; // If no error, it's valid\n  } catch (err) {\n    return false; // Corrupt or unsupported image\n  }\n};\n\nexport { isImage };\n","import sharp from \"sharp\";\nimport { isNumber } from \"./is-number\";\nimport { isImage } from \"./is-image\";\nimport { FitEnum } from \"sharp\";\nimport { Memoize } from \"@chriscdn/memoize\";\n\nexport type SharpifyParameters = {\n  blur: number; // https://sharp.pixelplumbing.com/api-operation#blur\n  brightness: number;\n  fit: keyof FitEnum;\n  height: number;\n  normalise: boolean; // https://sharp.pixelplumbing.com/api-operation#normalise\n  rotate: number;\n  saturation: number;\n  width: number;\n  withMetadata: boolean;\n  withoutEnlargement: boolean;\n};\n\n// we only ever render the same image once.. no need to cache\nsharp.cache(false);\n\nexport const sharpifyIt = async (\n  source: string,\n  target: string,\n  args: SharpifyParameters,\n) => {\n  const blur = assertIntegerValue(args.blur, 0, 100);\n  const brightness = assertIntegerValue(args.brightness, 0, 2);\n  const fit = args.fit;\n  const height = assertIntegerValue(args.height, 0, args.height);\n  const normalise = args.normalise;\n  const rotate = assertIntegerValue(args.rotate, -20, 20);\n  const saturation = assertIntegerValue(args.saturation, 0, 1);\n  const width = assertIntegerValue(args.width, 0, args.width);\n  const withMetadata = args.withMetadata;\n  const withoutEnlargement = args.withoutEnlargement;\n\n  let s = await sharp(source);\n\n  if (withMetadata) {\n    s = s.withMetadata();\n  }\n\n  const metadata = await s.metadata();\n\n  const originalWidth = metadata.width;\n  const originalHeight = metadata.height;\n\n  if (normalise) {\n    // normalise seems to have minimal effect\n    s = s.normalise();\n  }\n\n  if (isNumber(blur) && blur > 0) {\n    s = s.blur(blur);\n  }\n\n  if (isNumber(saturation) && saturation < 1) {\n    s = s.modulate({ saturation });\n  }\n\n  if (isNumber(brightness) && brightness != 1) {\n    s = s.modulate({ brightness });\n  }\n\n  if (rotate !== 0) {\n    // this doesnt take the orientation into account :(\n    // https://sharp.pixelplumbing.com/api-operation#rotate\n    s = s.rotate(rotate);\n\n    const box = boxify(originalWidth, originalHeight, rotate);\n\n    s = s.extract({\n      left: box.left,\n      top: box.top,\n      width: box.width,\n      height: box.height,\n    });\n  } else {\n    // this normalises rotation - see sharp docs\n    s = s.rotate();\n  }\n\n  if (width || height) {\n    s = s.resize({\n      width,\n      height,\n      fit,\n      withoutEnlargement,\n    });\n  }\n\n  await s.toFile(target);\n\n  if (await isImage(target)) {\n    // all good! exit gracefully\n    return target;\n  } else {\n    throw new Error(\"Invalid target generated.\");\n  }\n};\n\nconst assertIntegerValue = (\n  value: unknown,\n  min: number,\n  max: number,\n): number | null => {\n  if (isNumber(value)) {\n    return Math.min(max, Math.max(min, value));\n  } else {\n    return null;\n  }\n};\n\nconst radians = (degrees: number): number => {\n  return (degrees * Math.PI) / 180;\n};\n\nconst boxify = Memoize((width: number, height: number, degrees: number) => {\n  const rads = radians(Math.abs(degrees));\n\n  const sine = Math.sin(rads);\n  const cosine = Math.cos(rads);\n\n  let left = height * sine;\n  let top = width * sine;\n\n  const bigWidth = height * sine + width * cosine;\n  const bigHeight = height * cosine + width * sine;\n\n  let newWidth = bigWidth - 2 * left;\n  let newHeight = bigHeight - 2 * top;\n\n  const originalAspectRatio = width / height;\n  const newAspectRatio = newWidth / newHeight;\n\n  if (originalAspectRatio < newAspectRatio) {\n    const newWidthConstrained = originalAspectRatio * newHeight;\n\n    left = left + (newWidth - newWidthConstrained) / 2;\n    newWidth = newWidthConstrained;\n  } else {\n    // taller\n    const newHeightConstrained = newWidth / originalAspectRatio;\n\n    top = top + (newHeight - newHeightConstrained) / 2;\n    newHeight = newHeightConstrained;\n  }\n\n  return {\n    left: Math.round(left),\n    top: Math.round(top),\n    width: Math.round(newWidth),\n    height: Math.round(newHeight),\n    aspectRatio: newWidth / newHeight,\n  };\n});\n","import { Semaphore } from \"@chriscdn/promise-semaphore\";\nimport { sharpifyIt, type SharpifyParameters } from \"./_sharpify\";\n\nconst semaphore = new Semaphore();\n\nconst defaultArgs: SharpifyParameters = {\n  blur: 0,\n  brightness: 1,\n  fit: \"inside\",\n  height: null,\n  normalise: false,\n  rotate: 0,\n  saturation: 1,\n  width: null,\n  withMetadata: false,\n  withoutEnlargement: true,\n};\n\nexport const sharpify = async (\n  source: string,\n  target: string,\n  params: Partial<SharpifyParameters>,\n) => {\n  const args = {\n    ...defaultArgs,\n    ...params,\n  };\n\n  try {\n    await semaphore.acquire(target);\n\n    return await sharpifyIt(source, target, args);\n  } finally {\n    semaphore.release(target);\n  }\n};\n"],"names":["isNumber","num","trim","Number","isFinite","isImage","filePath","Promise","resolve","sharp","resize","toBuffer","then","_catch","cache","assertIntegerValue","value","min","max","Math","boxify","Memoize","width","height","degrees","rads","PI","radians","abs","sine","sin","cosine","cos","left","top","newWidth","newHeight","originalAspectRatio","newWidthConstrained","newHeightConstrained","round","aspectRatio","semaphore","Semaphore","defaultArgs","blur","brightness","fit","normalise","rotate","saturation","withMetadata","withoutEnlargement","source","target","params","args","_extends","acquire","s","metadata","originalWidth","originalHeight","modulate","box","extract","toFile","_isImage","Error","e","reject","sharpifyIt","_finallyRethrows","_wasThrown","_result","release"],"mappings":"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"}