{"version":3,"file":"sharpify.cjs","sources":["../src/is-number.ts","../src/is-image.ts","../src/_sharpify.ts","../src/sharpify.ts"],"sourcesContent":["/**\n * Based on https://www.npmjs.com/package/is-number, but modified as a\n * type-guard.\n *\n * @param num\n * @returns\n */\nexport const isNumber = (num: unknown): num is number => {\n    if (typeof num === \"number\") {\n        return num - num === 0;\n    } else if (typeof num === \"string\" && num.trim() !== \"\") {\n        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n    } else {\n        return false;\n    }\n};\n","export const isImage = async (filePath: string): Promise<boolean> => {\n  try {\n    //\n    // Seems necessary for the CJS export to work.\n    //\n    const { default: imageType } = await import(\"image-type\");\n    const { minimumBytes } = await import(\"image-type\");\n    const { readChunk } = await import(\"read-chunk\");\n\n    const buffer = await readChunk(filePath, { length: minimumBytes });\n    const type = await imageType(buffer);\n    return [\"image/jpeg\", \"image/png\"].includes(type?.mime ?? \"\");\n  } catch (e) {\n    return false;\n  }\n};\n","import sharp from \"sharp\";\nimport { isNumber } from \"./is-number\";\nimport { isImage } from \"./is-image\";\nimport { FitEnum } from \"sharp\";\nimport { Memoize } from \"@chriscdn/memoize\";\n\nexport type SharpifyParameters = {\n  blur: number; // https://sharp.pixelplumbing.com/api-operation#blur\n  brightness: number;\n  fit: keyof FitEnum;\n  height: number;\n  normalise: boolean; // https://sharp.pixelplumbing.com/api-operation#normalise\n  rotate: number;\n  saturation: number;\n  width: number;\n  withMetadata: boolean;\n  withoutEnlargement: boolean;\n};\n\n// we only ever render the same image once.. no need to cache\nsharp.cache(false);\n\nexport const sharpifyIt = async (\n  source: string,\n  target: string,\n  args: SharpifyParameters,\n) => {\n  const blur = assertIntegerValue(args.blur, 0, 100);\n  const brightness = assertIntegerValue(args.brightness, 0, 2);\n  const fit = args.fit;\n  const height = assertIntegerValue(args.height, 0, args.height);\n  const normalise = args.normalise;\n  const rotate = assertIntegerValue(args.rotate, -20, 20);\n  const saturation = assertIntegerValue(args.saturation, 0, 1);\n  const width = assertIntegerValue(args.width, 0, args.width);\n  const withMetadata = args.withMetadata;\n  const withoutEnlargement = args.withoutEnlargement;\n\n  let s = await sharp(source);\n\n  if (withMetadata) {\n    s = s.withMetadata();\n  }\n\n  const metadata = await s.metadata();\n\n  const originalWidth = metadata.width;\n  const originalHeight = metadata.height;\n\n  if (normalise) {\n    // normalise seems to have minimal effect\n    s = s.normalise();\n  }\n\n  if (isNumber(blur) && blur > 0) {\n    s = s.blur(blur);\n  }\n\n  if (isNumber(saturation) && saturation < 1) {\n    s = s.modulate({ saturation });\n  }\n\n  if (isNumber(brightness) && brightness != 1) {\n    s = s.modulate({ brightness });\n  }\n\n  if (rotate !== 0) {\n    // this doesnt take the orientation into account :(\n    // https://sharp.pixelplumbing.com/api-operation#rotate\n    s = s.rotate(rotate);\n\n    const box = boxify(originalWidth, originalHeight, rotate);\n\n    s = s.extract({\n      left: box.left,\n      top: box.top,\n      width: box.width,\n      height: box.height,\n    });\n  } else {\n    // this normalises rotation - see sharp docs\n    s = s.rotate();\n  }\n\n  if (width || height) {\n    s = s.resize({\n      width,\n      height,\n      fit,\n      withoutEnlargement,\n    });\n  }\n\n  await s.toFile(target);\n\n  if (await isImage(target)) {\n    // all good! exit gracefully\n    return target;\n  } else {\n    throw new Error(\"Invalid target generated.\");\n  }\n};\n\nconst assertIntegerValue = (\n  value: unknown,\n  min: number,\n  max: number,\n): number | null => {\n  if (isNumber(value)) {\n    return Math.min(max, Math.max(min, value));\n  } else {\n    return null;\n  }\n};\n\nconst radians = (degrees: number): number => {\n  return (degrees * Math.PI) / 180;\n};\n\nconst boxify = Memoize((width: number, height: number, degrees: number) => {\n  const rads = radians(Math.abs(degrees));\n\n  const sine = Math.sin(rads);\n  const cosine = Math.cos(rads);\n\n  let left = height * sine;\n  let top = width * sine;\n\n  const bigWidth = height * sine + width * cosine;\n  const bigHeight = height * cosine + width * sine;\n\n  let newWidth = bigWidth - 2 * left;\n  let newHeight = bigHeight - 2 * top;\n\n  const originalAspectRatio = width / height;\n  const newAspectRatio = newWidth / newHeight;\n\n  if (originalAspectRatio < newAspectRatio) {\n    const newWidthConstrained = originalAspectRatio * newHeight;\n\n    left = left + (newWidth - newWidthConstrained) / 2;\n    newWidth = newWidthConstrained;\n  } else {\n    // taller\n    const newHeightConstrained = newWidth / originalAspectRatio;\n\n    top = top + (newHeight - newHeightConstrained) / 2;\n    newHeight = newHeightConstrained;\n  }\n\n  return {\n    left: Math.round(left),\n    top: Math.round(top),\n    width: Math.round(newWidth),\n    height: Math.round(newHeight),\n    aspectRatio: newWidth / newHeight,\n  };\n});\n","import { Semaphore } from \"@chriscdn/promise-semaphore\";\nimport { sharpifyIt, type SharpifyParameters } from \"./_sharpify\";\n\nconst semaphore = new Semaphore();\n\nconst defaultArgs: SharpifyParameters = {\n  blur: 0,\n  brightness: 1,\n  fit: \"inside\",\n  height: null,\n  normalise: false,\n  rotate: 0,\n  saturation: 1,\n  width: null,\n  withMetadata: false,\n  withoutEnlargement: true,\n};\n\nexport const sharpify = async (\n  source: string,\n  target: string,\n  params: Partial<SharpifyParameters>,\n) => {\n  const args = {\n    ...defaultArgs,\n    ...params,\n  };\n\n  try {\n    await semaphore.acquire(target);\n\n    return await sharpifyIt(source, target, args);\n  } finally {\n    semaphore.release(target);\n  }\n};\n"],"names":["isNumber","num","trim","Number","isFinite","isImage","filePath","Promise","resolve","then","_interopNamespace","require","_ref","imageType","_ref2","minimumBytes","_ref3","readChunk","length","buffer","type","_type$mime","includes","mime","_catch","sharp","cache","assertIntegerValue","value","min","max","Math","boxify","Memoize","width","height","degrees","rads","PI","radians","abs","sine","sin","cosine","cos","left","top","newWidth","newHeight","originalAspectRatio","newWidthConstrained","newHeightConstrained","round","aspectRatio","semaphore","Semaphore","defaultArgs","blur","brightness","fit","normalise","rotate","saturation","withMetadata","withoutEnlargement","source","target","params","args","_extends","acquire","s","metadata","originalWidth","originalHeight","modulate","box","extract","resize","toFile","_isImage","Error","e","reject","sharpifyIt","_finallyRethrows","_wasThrown","_result","release"],"mappings":"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"}